[{"id":"867e4beaadd4d5a00bee5d31d8c3bbbf","title":"celery队列","content":"Celery简介1. 什么是任务队列任务队列是一种用于在线程或计算机之间分配工作的机制。\n任务队列的输入是一个称为任务的工作单元，有专门的职程（Worker）进行不断的监视任务队列，进行执行新的任务工作。\nCelery 通过消息机制进行通信，通常使用中间件（Broker）作为客户端和职程（Worker）调节。启动一个任务，客户端向消息队列发送一条消息，然后中间件（Broker）将消息传递给一个职程（Worker），最后由职程（Worker）执行。\nCelery 可以有多个职程（Worker）和中间件（Broker），用来提高Celery的高可用性以及横向扩展能力。\nCelery 需要消息中间件来进行发送和接收消息。 RabbitMQ 和 Redis 中间件的功能比较齐全，但也支持其它的实验性的解决方案，其 中包括 SQLite 进行本地开发。\nCelery 可以在一台机器上运行，也可以在多台机器上运行，甚至可以跨数据中心运行。\n2. Celery组件Celery 扮演生产者和消费者的角色\n\nCelery Beat：任务调度器。Beat 进程会读取配置文件的内容，周期性的将配置中到期需要执行的任务发送给任务队列。\n\nCelery Worker：执行任务的消费者，通常会在多台服务器运行多个消费者，提高运行效率。\n\nBroker：消息代理，队列本身。 也称为消息中间件。 接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方(通常是消息队列或者数据库)。\n\nProducer：任务生产者。 调用 Celery API ，函数或者装饰器，而产生任务并交给任务队列处理的都是任务生产者。\n\nResult Backend : 任务处理完成之后保存状态信息和结果，以供查询。\n\n\ncelery架构图\n\n3. Celery特点\n高可用\n\n当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务。\n\n快速\n\n一个单进程的 Celery 每分钟可以处理数以百万的任务，而且延迟仅为亚毫秒（使用 RabbitMQ、 librabbitmq 在优化过后）。\n\n灵活\n\nCelery 的每个部分几乎都可以自定义扩展和单独使用，例如自定义连接池、序列化方式、压缩方式、日志记录方式、任务调度、生产者、消费者、中间件（Broker）等。\n4. Celery功能\n监控\n\n可以针对整个流程进行监控，内置的工具可以实时说明当前集群的概况。\n\n调度\n\n可以通过调度功能在一段时间内指定任务的执行时间 datetime，也可以根据简单每隔一段时间进行执行重复的任务，支持分钟、小时、星期几，也支持某一天或某一年的Crontab表达式。\n\n工作流\n\n可以通过“canvas”进行组成工作流，其中包含分组、链接、分块等等。\n简单和复杂的工作流程可以使用一组“canvas“组成，其中包含分组、链接、分块等。\n\n资源（内存）泄漏保护\n\n–max-tasks-per-child 参数适用于可能会出现资源泄漏（例如：内存泄漏）的任务。\n\n时间和速率的限制\n\n您可以控制每秒/分钟/小时执行任务的次数，或者任务执行的最长时间，也将这些设置为默认值，针对特定的任务或程序进行定制化配置。\n\n自定义组件\n\n开发者可以定制化每一个职程（Worker）以及额外的组件。职程（Worker）是用 “bootsteps” 构建的-一个依赖关系图，可以对职程（Worker）的内部进行细粒度控制。\n5. 版本要求Celery 4.0 运行：\n\nPython ❨2.7,3.4,3.5❩  \n\nPyPy ❨5.4,5.5❩  \n\n\n这是支持 Python2.7 的最后一个版本，从下一个版本Celery5.x开始，需要Python3.5或更高的版本。\n如果您的 Python 运行环境比较老，则需要使用旧版本的Celery：\n\nPython 2.6：Celery 3.1 或更早版本。\nPython 2.5：Celery 3.0 或更早版本。\nPython 2.4：Celery 2.2 或更早版本。\n\n参考文章\nCelery 分布式任务队列 - 知乎 (zhihu.com)\n\n","slug":"celery队列","date":"2022-12-10T02:35:04.000Z","categories_index":"","tags_index":"Python面试题","author_index":"Dongbo Xie"},{"id":"06c05b6d3f59577fc268e145e3219741","title":"redis用过哪些数据结构？怎么保存的?","content":"Redis 的五种基本数据类型String（字符串）简介:String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M\n简单使用举例: set key value、get key等\n应用场景：共享session、分布式锁，计数器、限流。\n内部编码有3种，int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）\nHash（哈希）简介：在Redis中，哈希类型是指v（值）本身又是一个键值对（k-v）结构\n简单使用举例：hset key field value 、hget key field\n内部编码：ziplist（压缩列表） 、hashtable（哈希表）\n应用场景：缓存用户信息等。\nList（列表）简介：列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。\n简单实用举例：lpush key value [value …] 、lrange key start end\n内部编码：ziplist（压缩列表）、linkedlist（链表）\n应用场景：消息队列，文章列表\nSet（集合）简介：集合（set）类型也是用来保存多个的字符串元素，但是不允许重复元素\n简单使用举例：sadd key element [element …]、smembers key\n内部编码：intset（整数集合）、hashtable（哈希表）\n应用场景：用户标签,生成随机数抽奖、社交需求。\n有序集合（zset）简介：已排序的字符串集合，同时元素不能重复\n简单格式举例：zadd key score member [score member …]，zrank key member\n底层内部编码：ziplist（压缩列表）、skiplist（跳跃表）\n应用场景：排行榜，社交需求（如用户点赞）。\nRedis 的三种特殊数据类型\nGeo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。\n\nHyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。\n\nBitmaps ：用一个比特位来映射某个元素的状态，在Redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组\n\n\n\n在redisObject中 **[type表示属于哪种数据类型，encoding表示该数据的存储方式]**，也就是底层的实现的该数据类型的数据结构，ptr则是指向数据的存储。\nencoding中的存储类型所表示的含义如下图所示：\n\n数据的存储String类型的数据结构存储方式有三种int、raw、embstr。\nRedis中规定假如存储的是 **[整数型值]，比如set num 123这样的类型，就会使用 int的存储方式进行存储，在redisObject的[ptr属性]**中就会保存该值。\n\nSDS假如存储的**[字符串是一个字符串值并且长度大于32个字节]就会使用SDS(simple dynamic string)方式进行存储，并且encoding设置为raw；若是[字符串长度小于等于32个字节]**就会将encoding改为embstr来保存字符串。\n\n参考文章\nredis 超详细的Redis五种数据结构详解（理论+实战） - DoubleLi - 博客园 (cnblogs.com)\n\n每日一问：Redis有几种数据结构,底层分别是怎么存储的？_星仔学习的博客-CSDN博客\n\nRedis源码解析之SDS（缓存面试加分项） - 知乎 (zhihu.com)\n\n\n","slug":"redis用过哪些数据结构？怎么保存的","date":"2022-12-09T12:15:37.000Z","categories_index":"","tags_index":"","author_index":"Dongbo Xie"},{"id":"3850b7ec8b4d03677d6c891acbbc423d","title":"简述一个前端请求的处理流程，uWSGI/nginx/django之间的处理流程","content":"WSGI\nWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口\n参考文章\n尝试理解Flask源码 之 搞懂WSGI协议 - 知乎 (zhihu.com)\n\n\n\n","slug":"简述一个前端请求的处理流程，uwsgi-nginx-django之间的处理流程","date":"2022-12-09T06:07:57.000Z","categories_index":"","tags_index":"","author_index":"Dongbo Xie"},{"id":"9a515d5665a08874b409b4ff5ca7a5ad","title":"我的Hexo开发指南","content":"简介作为一个Hexo小白，现在我想要拥有一个Hexo的Aurora主题的博客网站，同时我还有一个域名（dongbox.space），我想通过这个域名访问到我的Hexo静态资源，但我没有服务器，所以我打算直接部署在pages服务上，我选择了Github Pages，整个部署过程会分为三部分：\n\n本地运行Hexo+Aurora主题\n\n将Hexo静态文件部署到Github Pages中，配置CloudFlare CDN\n\nHexo优化\n\n\n1. 本地运行Hexo+Aurora主题一、配置基本环境$ npm install hexo-cli -g\n$ hexo init blog\n$ cd blog\n$ npm install\n$ npm install hexo-theme-aurora --save\n$ npm install hexo-deployer-git -save\n\n二、根据文档修改相应配置Aurora官方文档地址\n$ cd blog\n$ cp ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n打开`_config.yml`文件开始修改配置\n\nStep 1：修改permalink为/post/:title.html# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: https://tridiamond.tech\npermalink: /post/:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\nStep 2：修改highlight为false，prismjs为truehighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n\nStep 3： 新建一个关于页面$ hexo new page about\n\nStep 4: 生成资源以及检测能否正常部署$ hexo clean\n$ hexo g\n$ hexo server\n\n参考文章\nHexo\nTheme | Hexo Aurora (tridiamond.tech)\n\n2. 将Hexo静态文件部署到Github Pages中，配置CloudFlare CDN一、将Hexo静态文件部署到Github Pages中\n创建一个名为dongbox.github.io的公共仓库\n\n链接本地Hexo项目到github仓库\n# 进入项目目录，此处更换为你的Hexo项目名称\ncd blog\n# 实例化本地仓库\ngit init\n# 链接仓库，此处更换为你的仓库地址\ngit remote add origin https://github.com/Dongbox/dongbox.github.io.git\n修改配置文件_config.yml中的远程仓库地址\ndeploy:\ntype: git\nrepo: https://github.com/Dongbox/dongbox.github.io.git\nbranch: main\n发布到Hexo\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n上传源码到远程仓库\n除了静态文件，我们还要上传Hexo源码文件。\n# 创建一个新的分支hexo\ngit checkout -b hexo\n# 添加文件到本地仓库\ngit add .\n# 提交声明\ngit commit -m '内容'\n# 推送源码到hexo分支\ngit push origin hexo\n\n二、配置CloudFlare CDN因为我的域名是在腾讯云购买的，所以我需要通过的腾讯云默认的DNSPOD来修改原有DNS为CloudFlare的DNS。\n在腾讯云管理中修改DNS服务器\nbrian.ns.cloudflare.com\n\npaityn.ns.cloudflare.com\n\n\n在CloudFlare配置CNAME\n@ dongbox.github.io\n\nwww dongbox.github.io\n\n\n参考文章\n基于 Hexo 的 GitHub Pages 配置 CloudFlare CDN_qhh0205的博客-CSDN博客\n\ncloudflare加速博客网站出现“此页面不能正确地重定向”的解决办法_喆旭电科的博客-CSDN博客_如何解决cloudflare\n\n\n","slug":"我的Hexo开发指南","date":"2022-12-09T02:10:33.000Z","categories_index":"","tags_index":"Hexo","author_index":"Dongbo Xie"},{"id":"698d6b72538462fa89b3c934a0b1d2e9","title":"深拷贝浅拷贝","content":"1、Python 深拷贝和浅拷贝概念理解前提知识\nPython 中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。\n\nis和 == 都是对对象进行比较判断作用的，但比较判断的内容并不相同：\n\n== 是python标准操作符中的比较操作符，用来比较判断两个对象的 value (值) 是否相等。\n\nis 也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是说它判断的是两个对象的 id是否相同。\n\n\n\n\n简介浅拷贝：重新分配一块内存，创建一个新的对象，但里面的元素是对原对象中各个子对象的引用（原地址）。\n深拷贝：重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中（新地址）。因此，新对象和原对象没有任何关联。\n直接的例子1.>>> import copy\n2.>>> a = 1\n3.>>> b = a\n4.>>> c = copy.copy(a)\n5.>>> d = copy.deepcopy(a)\n6.>>> id(a), id(b), id(c), id(d)\n7.(94423772740928, 94423772740928, 94423772740928, 94423772740928) # 无论采用哪种拷贝方式，都是完全相同的内存地址，因为只是增加了一个引用计数\n8.>>> e = 1 # 即使是直接赋值，只要值相同，也是与上面相同的内存地址\n9.>>> id(e)\n10.94423772740928\n11.>>> b = 2\n12.>>> id(b)\n13.94423772740960 # 一旦值不同，内存地址就不同\n\n浅拷贝的产生\n使用数据类型本身的构造器\n对于可变的序列，还可以通过切片操作符 : 来完成浅拷贝（元组、字符串除外）。\nPython 还提供了对应的函数 copy.copy() 函数，适用于任何数据类型\n\n\n\n\n\n\n\n\n\n\n当内层为可变数据类型时，深拷贝后内层外层地址均发生改变。当内层为不可变数据类型时，外层不管是可变还是不可变数据类型，使用深拷贝，都不会改变内层地址，只会在外层为可变数据类型时，改变外层地址。\n使用浅拷贝是只能在外层数据类型为可变数据类型时，才能改变外层地址。而内层地址，无论是否为可变数据类型还是不可变数据类型，使用浅拷贝都不会改变内层数据类型地址。\nRef\nPython中的浅拷贝和深拷贝（一看就懂！！！）_时代&amp;信念的博客-CSDN博客_python 深拷贝 浅拷贝\n\ncloudflare加速博客网站出现“此页面不能正确地重定向”的解决办法_喆旭电科的博客-CSDN博客_如何解决cloudflare\n\n\n","slug":"深拷贝浅拷贝","date":"2022-12-07T13:46:32.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-06T14:29:46.247Z","categories_index":"","tags_index":"","author_index":"Dongbo Xie"}]