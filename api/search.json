[{"id":"c4c29a0f3ee5d4305d5533c1af569c42","title":"Python：Python2与Python3","content":"\nprint() vs print\n\nUnicode vs ASCII\n\n除法：浮点 vs 整数\n\nStandardError废弃，统一使用Exception；raise去除raise IOError, &quot;&quot;格式，统一为raise IOError(&quot;file str&quot;)\n\nrange vs xrange\n\n去除&lt;&gt;不等运算符，统一为!=\n\n去除long类型\n\n新增了bytes\n\n去除.next()方法\n\ndict的has_key()方法被去掉\n\ndictiionary的keys()、values()、items()、zip()、map()、filter()不再直接返回list对象，但可以强制转换。\n\n\n参考文章\n深入浅析Python2.x和3.x版本的主要区别 _ 搞代码 (gaodaima.com)\n\n","slug":"Python：Python2与Python3","date":"2022-12-10T13:20:33.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"644c73fd2c19b0a9e69da32b079c908d","title":"Python：Django中的CSRF问题","content":"CORS简介CORS是一种允许与托管在不同域上的资源进行交互的机制。例如，应用它的最常见场景之一是Ajax请求。\n为了说明CORS是如何工作的，让我们假设您有一个位于domain.com中的web应用程序。但是，为了保存用户信息，应用程序调用部署在另一个url中的API，例如api.domain.com。因此，当将保存数据的请求发送到api.domain.com时，服务器将根据请求的头信息和请求的来源来校验请求。\n如果允许服务器中的URL domain.com，它将提供正确的响应。如果不允许该域，服务器将抛出一个异常。此信息交换使用HTTP报头进行。\n如果有CORS的需要，可以直接安装corsheaders\npip install django-cors-headers \n\nCSRF简介CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。\n模板请求在Django中，如果是直接使用模板来定义的话，那么可以直接声明：\n&#123; % csrf_token% &#125;\n\nAjax请求csrftoken这个值可以从cookie的csrftoken获取到。\n验证则有两种方式进行：\n\n在请求头中定义X-CSRFToken参数。\n\n在数据中定义csrf_token属性一同传过去\n\n\n参考文章\nDjango CORS Guide: What It Is and How to Enable It (stackhawk.com)\n\n","slug":"Python：Django中的CSRF问题","date":"2022-12-10T09:16:23.000Z","categories_index":"Python面试题","tags_index":"Python,Django","author_index":"Dongbo Xie"},{"id":"8410d9c49c9d1e56959240bb5a60df1e","title":"Python：Django模型类","content":"模型类继承一共有三种继承模式：\n\n抽象基类\n\n多表继承\n\n代理模型\n\n\n1. 抽象基类该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。\nfrom django.db import models\n\nclass CommonInfo(models.Model):\n    name = models.CharField(max_length=100)\n    age = models.PositiveIntegerField()\n\n    class Meta:\n        abstract = True  # Meta中声明为基类\n\n CommonInfo 模型不能用作普通的 Django 模型，因为它是一个抽象基类。它不会生成数据表，也没有管理器，也不能被实例化和保存。\n从抽象基类继承来的字段可被其它字段或值重写，或用 None 删除。\nMeta继承\n当一个抽象基类被建立，Django 将所有你在基类中申明的 Meta 内部类以属性的形式提供。若子类未定义自己的 Meta 类，它会继承父类的 Meta。当然，子类也可继承父类的 Meta，比如:\nfrom django.db import models\n\nclass CommonInfo(models.Model):\n    # ...\n    class Meta:\n        abstract = True\n        ordering = ['name']\n\nclass Student(CommonInfo):\n    # ...\n    class Meta(CommonInfo.Meta):\n        db_table = 'student_info'\n\n\n\n\n\n\n\n\n\n\nDjango 在实例化 Meta 属性前，对抽象基类的 Meta 做了一个调整——设置 abstract=False。因此抽象基类的子类不会自动地变成抽象类。\n如果子类从多个抽象基类继承，则默认情况下仅继承第一个列出的类的 Meta 选项。为了从多个抽象类中继承 Meta 选项，必须显式地声明 Meta 继承。\n...\nclass Unmanaged(models.Model):\n    class Meta:\n        abstract = True\n        managed = False\n\nclass Student(CommonInfo, Unmanaged):\n    home_group = models.CharField(max_length=5)\n\n    class Meta(CommonInfo.Meta, Unmanaged.Meta):\n        pass\n\n2. 多表继承Django 支持的第二种模型继承方式是层次结构中的每个模型都是一个单独的模型。每个模型都指向分离的数据表，且可被独立查询和创建。\n\n\n\n\n\n\n\n\n\n可以理解为自动创建了一个OneToOneField。\nfrom django.db import models\n\nclass Place(models.Model):\n    name = models.CharField(max_length=50)\n    address = models.CharField(max_length=80)\n\nclass Restaurant(Place):\n    serves_hot_dogs = models.BooleanField(default=False)\n    serves_pizza = models.BooleanField(default=False)\n\nPlace 的所有字段均在 Restaurant 中可用，虽然数据分别存在不同的表中。所有，以下操作均可:\n>>> Place.objects.filter(name=\"Bob's Cafe\")\n>>> Restaurant.objects.filter(name=\"Bob's Cafe\")\n\n若有一个 Place 同时也是 Restaurant，你可以通过小写的模型名将 Place 对象转为 Restaurant 对象。\n>>> p = Place.objects.get(id=12)\n# If p is a Restaurant object, this will give the child class:\n>>> p.restaurant\n&lt;Restaurant: ...>\n\n然而，若上述例子中的 p 不是 一个 Restaurant （它仅是个 Place 对象或是其它类的父类），指向 p.restaurant 会抛出一个 Restaurant.DoesNotExist 异常。\nRestaurant 中自动创建的连接至 Place 的 OneToOneField 看起来像这样:\nplace_ptr = models.OneToOneField(\n    Place, on_delete=models.CASCADE,\n    parent_link=True,\n    primary_key=True,\n)\n\n\n\n\n\n\n\n\n\n\n你可以在 Restaurant 中重写该字段，通过申明你自己的 OneToOneField，并设置 parent_link=True。\n关于多表继承中的Meta多表继承情况下，子类不会继承父类的 Meta\n因此子类模型无法访问父类的 Meta 类。不过，有限的几种情况下：若子类未指定 ordering 属性或 get_latest_by 属性，子类会从父类继承这些。\n3. 代理模型使用 多表继承 时，每个子类模型都会创建一张新表。这一般是所期望的行为，因为子类需要一个地方存储基类中不存在的额外数据字段。不过，有时候你只想修改模型的部分属性——比如修改默认管理器，或添加一个方法。\n这个时候就是代理模型出手的时候了，为原模型创建一个 代理。你可以创建，删除和更新代理模型的实例，所以的数据都会存储的像你使用原模型（未代理的）一样。不同点是你可以修改代理默认的模型排序和默认管理器，而不需要修改原模型。\nfrom django.db import models\n\nclass Person(models.Model):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n\nclass MyPerson(Person):\n    class Meta:\n        proxy = True\n\n    def do_something(self):  # 添加一个方法，但仍然和父类操作的是同一张表\n        # ...\n        pass\n\nMyPerson 类与父类 Person 操作同一张数据表。特别提醒， Person 的实例能通过 MyPerson 访问，反之亦然。\n>>> p = Person.objects.create(first_name=\"foobar\")\n>>> MyPerson.objects.get(first_name=\"foobar\")\n&lt;MyPerson: foobar>\n\n也可以只是简单修改下排序模式，比如代理模型按照last_name进行排序。\nclass OrderedPerson(Person):\n    class Meta:\n        ordering = [\"last_name\"]\n        proxy = True\n\n那么普通的 Person 查询结果不会被排序，但 OrderdPerson 查询接轨会按 last_name 排序。\n基类约束\n一个代理模型必须继承自一个非抽象模型类。你不能继承多个非抽象模型类，因为代理模型无法在不同数据表之间提供任何行间连接。一个代理模型可以继承任意数量的抽象模型类，假如他们 没有 定义任何的模型字段。一个代理模型也可以继承任意数量的代理模型，只需他们共享同一个非抽象父类。\n代理模型管理器\n若你未在代理模型中指定模型管理器，它会从父类模型中继承。如果你在代理模型中指定了管理器，它会成为默认管理器，但父类中定义的管理器仍是可用的。\nfrom django.db import models\n\nclass NewManager(models.Manager):\n    # ...\n    pass\n\nclass MyPerson(Person):\n    objects = NewManager()\n\n    class Meta:\n        proxy = True\n\n时间模型类pip install django-model-utils\n项目地址\n参考文章\n模型 | Django 文档 | Django\n\nDjango扩展用户模型_不负韶华ღ的博客-CSDN博客_django扩展用户\n\n\n","slug":"Python：Django模型类","date":"2022-12-10T08:17:36.000Z","categories_index":"Python面试题","tags_index":"Python,Django","author_index":"Dongbo Xie"},{"id":"1e75bb07e5af1c2f8f74b87cd88f4fd3","title":"Python：闭包","content":"简介在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。\n上面这段话实际上解释了闭包的一个定义和两个作用：\n\n定义：闭包就是能够读取外部函数内的变量的函数。（前面已经讲解过）\n\n作用1：闭包是将外层函数内的局部变量和外层函数的外部连接起来的一座桥梁。\n\n作用2：将外层函数的变量持久地保存在内存中。\n\n\n\n\n\n\n\n\n\n\n\n支持将函数当成对象使用的编程语言，一般都支持闭包。比如Python, JavaScript。\n作用1. 读取函数内部的变量有时候会为了保证命名空间的干净而把一些变量隐藏到函数内部，作为局部变量。但是由于Python中作用域的搜索顺序，函数内的变量不会被函数外的代码读取到。\n如果这时候想要函数外部的代码能够读取函数内部的变量，那么就可以使用闭包。\n\n\n\n\n\n\n\n\n\n闭包存在的意义就是它夹带了外部变量（私货），如果它不夹带私货，它和普通的函数就没有任何区别。同一个的函数夹带了不同的私货，就实现了不同的功能。  其实你也可以这么理解，闭包和面向接口编程的概念很像，可以把闭包理解成轻量级的接口封装。—-@Wayne\n2. 让函数内部的局部变量始终保持在内存中一般来说，函数内部的局部变量在这个函数运行完以后，就会被Python的垃圾回收机制从内存中清除掉。如果我们希望这个局部变量能够长久的保存在内存中，那么就可以用闭包来实现这个功能。\n闭包使得函数的实例对象的内部变量，变得很像一个类的实例对象的属性，可以一直保存在内存中，并不断的对其进行运算。\n总结\n局部变量无法共享和长久的保存，而全局变量可能造成变量污染，闭包既可以长久的保存变量又不会造成全局污染。\n闭包使得函数内局部变量的值始终保持在内存中，不会在外层函数调用后被自动清除。\n当外层函数返回了内层函数后，外层函数的局部变量还被内层函数引用\n带参数的装饰器，那么一般都会生成闭包。\n闭包在爬虫以及web应用中都有很广泛的应用。\n\n参考文章\nPython闭包（Closure）详解 - 知乎 (zhihu.com)\n\n深入浅出python闭包 - 知乎 (zhihu.com)\n\n\n","slug":"Python：闭包","date":"2022-12-10T07:50:14.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"44618c7f6520782d55b1b922f6fa7af4","title":"MYSQL优化与多表查询","content":"参考文章\n最全Mysql查询性能优化总结（超详细） - 知乎 (zhihu.com)\n\n【MySQL笔记】多表查询（JOIN ON）_java小白。。的博客-CSDN博客_mysql join on\n\n\n","slug":"MYSQL优化与多表查询","date":"2022-12-10T05:52:12.000Z","categories_index":"Python面试题","tags_index":"Database","author_index":"Dongbo Xie"},{"id":"557c3a65716469700d953ea750417d1a","title":"排序算法","content":"归并排序算法思想\n\n\n\n\n\n\n\n\n\n归并排序是一种递归算法，它持续地将一个列表分成两半。如果列表是空的或者 只有一个元素，那么根据定义，它就被排序好了（最基本的情况）。如果列表里的元素超过一个，我们就把列表拆分，然后分别对两个部分调用递归排序。一旦这两个部分被排序好了，然后就可以对这两部分数列进行归并了。归并是这样一个过程：把两个排序好了的列表结合在一起组合成一个单一的有序的新列表。有自顶向下（递归法）和自底向上的两种实现方法。\n快速排序算法思想\n\n\n\n\n\n\n\n\n\n快速排序由 C. A. R. Hoare 在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n算法步骤\n\n从数列中挑出一个元素，称为”基准”（pivot）。\n重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n快速排序一些可以优化的点\n\n当数列近乎有序的时，由于每次选取的都是第一个数，所以造成数列分割的极其不等\n\n参考文章\n十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)\n\n常用的排序算法总结 - 知乎 (zhihu.com)\n\n\n","slug":"排序算法","date":"2022-12-10T05:12:35.000Z","categories_index":"Python面试题","tags_index":"Algorithm","author_index":"Dongbo Xie"},{"id":"061f80859bc6d460d6ca6944c3b9b34e","title":"数据结构：堆和栈","content":"什么是堆（一）堆的定义一个大小为 n 的堆（heap） 是一棵包含 n 个结点的 完全二叉树，其根节点称为堆顶，根据堆中亲自结点的大小关系，堆可以分为两类。（1）最小堆：如果树中每个结点的元素都小于或等于其孩子结点的元素，则称该堆为最小堆。在最小堆中，堆顶存储的元素是整棵树中最小的。（2）最大堆：如果树中每个结点的元素都大于或等于其孩子结点的元素，则称该堆为最大堆。在最大堆中，堆顶存储的元素是整棵树中最小的。\n（二）堆的存储结构堆的逻辑结构是树形结构，并且是一种特殊的树形结构——完全二叉树。对于堆而言，在物理存储上仍然采用的是顺序存储表示。\n什么是栈（一）堆的定义栈(stack)是限定仅在表尾进行插入和删除的线性表。\n（二）堆的存储结构\n允许插入和删除的一段称为栈顶(top)，另一端称为栈底(bottom)，不含任何元素的栈称为空栈。栈又称后进先出的(Last In First Out)线性表，简称LIFO结构。\n栈的插入操作，叫作进栈，也称压栈、入栈。\n栈的删除操作，叫作出栈，有的也叫弹栈。\n参考文章\npython数据结构之堆(heap) - 秒客网 (miaokee.com)\n\n数据结构之堆_亦是远方的博客-CSDN博客_堆是逻辑结构还是存储结构\n\n数据结构——栈的顺序存储结构_洛语言的博客-CSDN博客_数据结构栈的顺序存储\n\n\n","slug":"数据结构：堆和栈","date":"2022-12-10T03:50:12.000Z","categories_index":"Python面试题","tags_index":"Algorithm","author_index":"Dongbo Xie"},{"id":"012543d9b947c1da60945007fb97dc9c","title":"向量化–one-hot编码/数据分箱","content":"为什么使用One-Hot编码？对于机器学习任务中，特征并不总是连续值，很多是分类值。这些分类值本身没有大小的意义。为了将数据集中一个分类变量替换为一个或多个新特征，我们使用One-Hot编码对数据进行预处理。\n因为大部分算法是基于向量空间中的度量来进行计算的，为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距，从而使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。\n为什么特征向量要映射到欧式空间？​ 将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。\n什么是One-Hot编码独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效(即各种属性之间相互排斥)。\n简而言之，即把离散的特征的每一种取值都看成一种状态。\n这样做的好处主要有：\n\n解决了分类器不好处理属性数据的问题\n\n在一定程度上也起到了扩充特征的作用\n\n\n为什么要进行分箱操作?分箱之后，数值型变量的取值空间缩小，也就取值的数量变少了，每个取值的样本量增多，方差变小，但相应的偏差变大了，也就是数据所能提供的信息没有分箱前那么精确了。\n但是对于分类变量而言，如果类别太多，可能存在个别类别样本量过少，对于数值型变量可能会存在极端值，这都会影响分析的稳健性。这样做可以有助于处理异常值或者样本量较少的值，提高稳定性，并且能够处理与目标变量的非线性关系，从而便于分析，让分析结果或者模型预测更加稳健。\n常见的特征分箱的方法根据有无目标变量，特征分箱的方法可分为两种：\n\n无监督分箱：如等宽(equal width)、等深\\等频（equal depth)、聚类分析等\n有监督分箱：如决策树、卡方分箱、生存模型分箱、best—KS、遗传算法分箱等。\n\n对于特征的分箱，按步骤可分为两步：\n\n细分箱：就是先把原始变量分出一些区间\n粗分箱：按照临近属性是否相同将相邻的区间进行合并，放到同一类。\n\n参考文章\n数据挖掘过程中特征离散化（分箱）方法介绍 - 知乎 (zhihu.com)\n\n","slug":"向量化–one-hot编码-数据分箱","date":"2022-12-10T03:12:32.000Z","categories_index":"Python面试题","tags_index":"Feature Engineering","author_index":"Dongbo Xie"},{"id":"425ef74df346723b32c51d5af54d8ea2","title":"Tornado与WSGI","content":"简介tornado是由F打头的404网站收购并且开源出来的Web框架, 他的第一个特点奏是将HTTP服务器和Web应用整合到了一起.\n所以可以用tornado搭建出来的服务器模型如下\n\n这就是我们刚才说的接受请求, 处理请求, 返回请求都是一个人, 感觉也不错.\n但是请注意了, 虽然表面上看起来这好像是一个人处理的, 但是我们在编写处理业务逻辑的代码时, 肯定不会去碰服务器相关的代码, 只需要写好视图和路由就可以了, 因此对于tornado来说, 他的服务器部分和逻辑处理部分还是分开的. 这就相当于虽然是一个人, 但是他的手和大脑是两个部分.\n实际上长这样\n\n这里有两个问题.\n\n如果我不想用tornado这个框架写逻辑部分, 那么我也一定不能使用它的服务器部分.  \n\n如果我就想用它的Web框架, 想换一个性能更加强大的服务器(软件), 似乎也做不到.  \n\n\n谁叫他们是一个人呢!\n这就是所谓的没有可移植性\n\n\n\n\n\n\n\n\n\n请注意:实际上, tornado的服务器和Web框架是兼容WSGI协议的, 有兴趣的话可以自己搜索一下相关内容.举这个例子是因为在Python Web框架中, tornado实现了高性能的HTTP服务器仅此而已.  \n如果百度过Tornado的也许知道他有一个很大的特点就是, 异步, 非阻塞, 高性能之类的. 其实, 这个特点说是他的HTTP服务器部分, tornado服务器擅长处理多个长连接, 可以用于在线聊天等业务场景.\n参考文章\n尝试理解Flask源码 之 搞懂WSGI协议 - 知乎 (zhihu.com)\n\n【web前端】详解Tornado web框架！ - 知乎 (zhihu.com)\n\n\n","slug":"Tornado与WSGI","date":"2022-12-10T03:00:35.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"47bf6e8451025e3a41bf23052e6c8743","title":"Python：进程、线程与协程","content":"基本概念进程(Process)进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。\n线程(Lightweight Process，LWP)线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。\n协程(Coroutines)协程是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。\n进程、线程、协程的对比:(1)协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。\n(2)一个进程可以包含多个线程，一个线程可以包含多个协程。\n(3)一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。\n(4)协程与进程、线程一样，切换是存在上下文切换问题的。\n上下文切换对比：(1)进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。\n(2)线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。线程的切换内容包括内核栈和硬件上下文,线程切换内容保存在内核栈中.线程切换过程是由“用户态到内核态到用户态”，切换效率中等。因为线程的调度是在内核态运行的，而线程中的代码是在用户态运行，因此线程切换会导致用户态与内核态的切换\n(4)协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。\n参考文章\n进程/线程/协程的区别_CoreDump1024的博客-CSDN博客_协程和线程和进程的区别\n\n浅析Python的进程、线程与协程 - 知乎 (zhihu.com)\n\n\n","slug":"Python：进程、线程与协程","date":"2022-12-10T02:54:10.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"16a21e0bb1a0e0b088f32d8aa8cd1960","title":"ModelFirst与DBFirst","content":"\n\n\n\n\n\n\n\n\nEF（Entity Framework（实体框架））是微软出品的用来操作数据库的一个框架。  \nEF 的三种设计模型：CodeFirst，ModelFirst，DBFirst。ModelFirst是首先设计实体模型，之后根据实体模型实现到数据库的映射。DBFirst是先进行数据库的设计，之后根据数据库生成实体数据模型。\nEF 框架的原理就是把实体类的变化通过映射反应到数据库中去，实现表的增删改查。对象上下文是实体类操作数据库的API。应用程序对实体类进行的增删改查操作会经由对象上下文进行映射，最终转换为 SQL 脚本语言，然后执行，最终实现对表的增删改查。当需要修改表的结构时，我们可以选择根据模型更新数据库和根据数据库更新模型两种。\n参考文章\nPython面试笔记-pudn.com\n\n","slug":"ModelFirst-DBFirst区别？","date":"2022-12-10T02:43:08.000Z","categories_index":"Python面试题","tags_index":"Database","author_index":"Dongbo Xie"},{"id":"79863d3505b89f135bc4e3895976782e","title":"Python：celery队列","content":"Celery简介1. 什么是任务队列任务队列是一种用于在线程或计算机之间分配工作的机制。\n任务队列的输入是一个称为任务的工作单元，有专门的职程（Worker）进行不断的监视任务队列，进行执行新的任务工作。\nCelery 通过消息机制进行通信，通常使用中间件（Broker）作为客户端和职程（Worker）调节。启动一个任务，客户端向消息队列发送一条消息，然后中间件（Broker）将消息传递给一个职程（Worker），最后由职程（Worker）执行。\nCelery 可以有多个职程（Worker）和中间件（Broker），用来提高Celery的高可用性以及横向扩展能力。\nCelery 需要消息中间件来进行发送和接收消息。 RabbitMQ 和 Redis 中间件的功能比较齐全，但也支持其它的实验性的解决方案，其 中包括 SQLite 进行本地开发。\nCelery 可以在一台机器上运行，也可以在多台机器上运行，甚至可以跨数据中心运行。\n2. Celery组件Celery 扮演生产者和消费者的角色\n\nCelery Beat：任务调度器。Beat 进程会读取配置文件的内容，周期性的将配置中到期需要执行的任务发送给任务队列。\n\nCelery Worker：执行任务的消费者，通常会在多台服务器运行多个消费者，提高运行效率。\n\nBroker：消息代理，队列本身。 也称为消息中间件。 接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方(通常是消息队列或者数据库)。\n\nProducer：任务生产者。 调用 Celery API ，函数或者装饰器，而产生任务并交给任务队列处理的都是任务生产者。\n\nResult Backend : 任务处理完成之后保存状态信息和结果，以供查询。\n\n\ncelery架构图\n\n3. Celery特点\n高可用\n\n当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务。\n\n快速\n\n一个单进程的 Celery 每分钟可以处理数以百万的任务，而且延迟仅为亚毫秒（使用 RabbitMQ、 librabbitmq 在优化过后）。\n\n灵活\n\nCelery 的每个部分几乎都可以自定义扩展和单独使用，例如自定义连接池、序列化方式、压缩方式、日志记录方式、任务调度、生产者、消费者、中间件（Broker）等。\n4. Celery功能\n监控\n\n可以针对整个流程进行监控，内置的工具可以实时说明当前集群的概况。\n\n调度\n\n可以通过调度功能在一段时间内指定任务的执行时间 datetime，也可以根据简单每隔一段时间进行执行重复的任务，支持分钟、小时、星期几，也支持某一天或某一年的Crontab表达式。\n\n工作流\n\n可以通过“canvas”进行组成工作流，其中包含分组、链接、分块等等。\n简单和复杂的工作流程可以使用一组“canvas“组成，其中包含分组、链接、分块等。\n\n资源（内存）泄漏保护\n\n–max-tasks-per-child 参数适用于可能会出现资源泄漏（例如：内存泄漏）的任务。\n\n时间和速率的限制\n\n您可以控制每秒/分钟/小时执行任务的次数，或者任务执行的最长时间，也将这些设置为默认值，针对特定的任务或程序进行定制化配置。\n\n自定义组件\n\n开发者可以定制化每一个职程（Worker）以及额外的组件。职程（Worker）是用 “bootsteps” 构建的-一个依赖关系图，可以对职程（Worker）的内部进行细粒度控制。\n5. 版本要求Celery 4.0 运行：\n\nPython ❨2.7,3.4,3.5❩  \n\nPyPy ❨5.4,5.5❩  \n\n\n这是支持 Python2.7 的最后一个版本，从下一个版本Celery5.x开始，需要Python3.5或更高的版本。\n如果您的 Python 运行环境比较老，则需要使用旧版本的Celery：\n\nPython 2.6：Celery 3.1 或更早版本。\nPython 2.5：Celery 3.0 或更早版本。\nPython 2.4：Celery 2.2 或更早版本。\n\n参考文章\nCelery 分布式任务队列 - 知乎 (zhihu.com)\n\n","slug":"Python：celery队列","date":"2022-12-10T02:35:04.000Z","categories_index":"Python面试题","tags_index":"Python,MQ","author_index":"Dongbo Xie"},{"id":"06c05b6d3f59577fc268e145e3219741","title":"redis用过哪些数据结构？怎么保存的?","content":"Redis 的五种基本数据类型String（字符串）简介:String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M\n简单使用举例: set key value、get key等\n应用场景：共享session、分布式锁，计数器、限流。\n内部编码有3种，int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）\nHash（哈希）简介：在Redis中，哈希类型是指v（值）本身又是一个键值对（k-v）结构\n简单使用举例：hset key field value 、hget key field\n内部编码：ziplist（压缩列表） 、hashtable（哈希表）\n应用场景：缓存用户信息等。\nList（列表）简介：列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。\n简单实用举例：lpush key value [value …] 、lrange key start end\n内部编码：ziplist（压缩列表）、linkedlist（链表）\n应用场景：消息队列，文章列表\nSet（集合）简介：集合（set）类型也是用来保存多个的字符串元素，但是不允许重复元素\n简单使用举例：sadd key element [element …]、smembers key\n内部编码：intset（整数集合）、hashtable（哈希表）\n应用场景：用户标签,生成随机数抽奖、社交需求。\n有序集合（zset）简介：已排序的字符串集合，同时元素不能重复\n简单格式举例：zadd key score member [score member …]，zrank key member\n底层内部编码：ziplist（压缩列表）、skiplist（跳跃表）\n应用场景：排行榜，社交需求（如用户点赞）。\nRedis 的三种特殊数据类型\nGeo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。\n\nHyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。\n\nBitmaps ：用一个比特位来映射某个元素的状态，在Redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组\n\n\n\n在redisObject中 **[type表示属于哪种数据类型，encoding表示该数据的存储方式]**，也就是底层的实现的该数据类型的数据结构，ptr则是指向数据的存储。\nencoding中的存储类型所表示的含义如下图所示：\n\n数据的存储String类型的数据结构存储方式有三种int、raw、embstr。\nRedis中规定假如存储的是 **[整数型值]，比如set num 123这样的类型，就会使用 int的存储方式进行存储，在redisObject的[ptr属性]**中就会保存该值。\n\nSDS假如存储的**[字符串是一个字符串值并且长度大于32个字节]就会使用SDS(simple dynamic string)方式进行存储，并且encoding设置为raw；若是[字符串长度小于等于32个字节]**就会将encoding改为embstr来保存字符串。\n\n参考文章\nredis 超详细的Redis五种数据结构详解（理论+实战） - DoubleLi - 博客园 (cnblogs.com)\n\n每日一问：Redis有几种数据结构,底层分别是怎么存储的？_星仔学习的博客-CSDN博客\n\nRedis源码解析之SDS（缓存面试加分项） - 知乎 (zhihu.com)\n\nRedis 速度快的原因_Powerstot的博客-CSDN博客_redis速度快的原因\n\n\n","slug":"redis用过哪些数据结构？怎么保存的","date":"2022-12-09T12:15:37.000Z","categories_index":"Python面试题","tags_index":"Database","author_index":"Dongbo Xie"},{"id":"3850b7ec8b4d03677d6c891acbbc423d","title":"简述一个前端请求的处理流程，uWSGI/nginx/django之间的处理流程","content":"WSGI\nWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口\n参考文章\n尝试理解Flask源码 之 搞懂WSGI协议 - 知乎 (zhihu.com)\n\n\n\n","slug":"简述一个前端请求的处理流程，uwsgi-nginx-django之间的处理流程","date":"2022-12-09T06:07:57.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"9a515d5665a08874b409b4ff5ca7a5ad","title":"我的Hexo开发指南","content":"简介作为一个Hexo小白，现在我想要拥有一个Hexo的Aurora主题的博客网站，同时我还有一个域名（dongbox.space），我想通过这个域名访问到我的Hexo静态资源，但我没有服务器，所以我打算直接部署在pages服务上，我选择了Github Pages，整个部署过程会分为三部分：\n\n本地运行Hexo+Aurora主题\n\n将Hexo静态文件部署到Github Pages中，配置CloudFlare CDN\n\nHexo优化\n\n\n1. 本地运行Hexo+Aurora主题一、配置基本环境$ npm install hexo-cli -g\n$ hexo init blog\n$ cd blog\n$ npm install\n$ npm install hexo-theme-aurora --save\n$ npm install hexo-deployer-git -save\n\n二、根据文档修改相应配置Aurora官方文档地址\n$ cd blog\n$ cp ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n打开`_config.yml`文件开始修改配置\n\nStep 1：修改permalink为/post/:title.html# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: https://tridiamond.tech\npermalink: /post/:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\nStep 2：修改highlight为false，prismjs为truehighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n\nStep 3： 新建一个关于页面$ hexo new page about\n\nStep 4: 生成资源以及检测能否正常部署$ hexo clean\n$ hexo g\n$ hexo server\n\n参考文章\nHexo\nTheme | Hexo Aurora (tridiamond.tech)\n\n2. 将Hexo静态文件部署到Github Pages中，配置CloudFlare CDN一、将Hexo静态文件部署到Github Pages中\n创建一个名为dongbox.github.io的公共仓库\n\n链接本地Hexo项目到github仓库\n# 进入项目目录，此处更换为你的Hexo项目名称\ncd blog\n# 实例化本地仓库\ngit init\n# 链接仓库，此处更换为你的仓库地址\ngit remote add origin https://github.com/Dongbox/dongbox.github.io.git\n修改配置文件_config.yml中的远程仓库地址\ndeploy:\ntype: git\nrepo: https://github.com/Dongbox/dongbox.github.io.git\nbranch: main\n发布到Hexo\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n上传源码到远程仓库\n除了静态文件，我们还要上传Hexo源码文件。\n# 创建一个新的分支hexo\ngit checkout -b hexo\n# 添加文件到本地仓库\ngit add .\n# 提交声明\ngit commit -m '内容'\n# 推送源码到hexo分支\ngit push origin hexo\n\n二、配置CloudFlare CDN因为我的域名是在腾讯云购买的，所以我需要通过的腾讯云默认的DNSPOD来修改原有DNS为CloudFlare的DNS。\n在腾讯云管理中修改DNS服务器\nbrian.ns.cloudflare.com\n\npaityn.ns.cloudflare.com\n\n\n在CloudFlare配置CNAME\n@ dongbox.github.io\n\nwww dongbox.github.io\n\n\n参考文章\n基于 Hexo 的 GitHub Pages 配置 CloudFlare CDN_qhh0205的博客-CSDN博客\n\ncloudflare加速博客网站出现“此页面不能正确地重定向”的解决办法_喆旭电科的博客-CSDN博客_如何解决cloudflare\n\n\n","slug":"我的Hexo开发指南","date":"2022-12-09T02:10:33.000Z","categories_index":"","tags_index":"Hexo","author_index":"Dongbo Xie"},{"id":"698d6b72538462fa89b3c934a0b1d2e9","title":"深拷贝浅拷贝","content":"1、Python 深拷贝和浅拷贝概念理解前提知识\nPython 中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。\n\nis和 == 都是对对象进行比较判断作用的，但比较判断的内容并不相同：\n\n== 是python标准操作符中的比较操作符，用来比较判断两个对象的 value (值) 是否相等。\n\nis 也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是说它判断的是两个对象的 id是否相同。\n\n\n\n\n简介浅拷贝：重新分配一块内存，创建一个新的对象，但里面的元素是对原对象中各个子对象的引用（原地址）。\n深拷贝：重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中（新地址）。因此，新对象和原对象没有任何关联。\n直接的例子1.>>> import copy\n2.>>> a = 1\n3.>>> b = a\n4.>>> c = copy.copy(a)\n5.>>> d = copy.deepcopy(a)\n6.>>> id(a), id(b), id(c), id(d)\n7.(94423772740928, 94423772740928, 94423772740928, 94423772740928) # 无论采用哪种拷贝方式，都是完全相同的内存地址，因为只是增加了一个引用计数\n8.>>> e = 1 # 即使是直接赋值，只要值相同，也是与上面相同的内存地址\n9.>>> id(e)\n10.94423772740928\n11.>>> b = 2\n12.>>> id(b)\n13.94423772740960 # 一旦值不同，内存地址就不同\n\n浅拷贝的产生\n使用数据类型本身的构造器\n对于可变的序列，还可以通过切片操作符 : 来完成浅拷贝（元组、字符串除外）。\nPython 还提供了对应的函数 copy.copy() 函数，适用于任何数据类型\n\n\n\n\n\n\n\n\n\n\n当内层为可变数据类型时，深拷贝后内层外层地址均发生改变。当内层为不可变数据类型时，外层不管是可变还是不可变数据类型，使用深拷贝，都不会改变内层地址，只会在外层为可变数据类型时，改变外层地址。\n使用浅拷贝是只能在外层数据类型为可变数据类型时，才能改变外层地址。而内层地址，无论是否为可变数据类型还是不可变数据类型，使用浅拷贝都不会改变内层数据类型地址。\nRef\nPython中的浅拷贝和深拷贝（一看就懂！！！）_时代&amp;信念的博客-CSDN博客_python 深拷贝 浅拷贝\n\ncloudflare加速博客网站出现“此页面不能正确地重定向”的解决办法_喆旭电科的博客-CSDN博客_如何解决cloudflare\n\n\n","slug":"深拷贝浅拷贝","date":"2022-12-07T13:46:32.000Z","categories_index":"Python面试题","tags_index":"Python","author_index":"Dongbo Xie"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-12-06T14:29:46.247Z","categories_index":"","tags_index":"","author_index":"Dongbo Xie"}]