{"title":"深入Python","uid":"48a973ff2817f5c6922953ec99a3d627","slug":"深入Python","date":"2022-12-13T07:33:51.000Z","updated":"2022-12-13T08:28:56.083Z","comments":true,"path":"api/articles/深入Python.json","keywords":null,"cover":null,"content":"<h3 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法\"></a>魔术方法</h3><ul>\n<li><p><code>__init__</code> 为构建好的对象赋予初始化</p>\n</li>\n<li><p><code>__new__</code> 分配内存空间，并返回构建好的对象（地址）</p>\n</li>\n<li><p><code>__del__</code> 从内存中清除对象，对象会默认执行方法。具体执行的时间节点</p>\n</li>\n<li><p><code>__call__</code>  当作函数执行时会被默认自动调用</p>\n</li>\n<li><p><code>__str__</code> 打印一个对象的时候，默认调用；在使用str()对对象强制类型转换后，输出结果时会调用</p>\n</li>\n<li><p><code>__repr__</code> repr方法作用和str方法的作用一样，都是输出对象打印的字符串格式。但最大的不同点在于：<br>在可变容器中，对象打印默认会调用repr方法。</p>\n</li>\n</ul>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><ul>\n<li><a href=\"https://blog.csdn.net/qq_53893431/article/details/123979718\">python——魔术方法_影中人lx的博客-CSDN博客_python魔术方法</a></li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"可迭代对象、迭代器、生成器\"><a href=\"#可迭代对象、迭代器、生成器\" class=\"headerlink\" title=\"可迭代对象、迭代器、生成器\"></a>可迭代对象、迭代器、生成器</h4><h4 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h4><ul>\n<li>可迭代对象就是从循环中依次取出来的对象。</li>\n<li>常见的可迭代对象有：list，tuple，string，dict，range</li>\n<li>常见的不可迭代的对象有：数字，布尔值</li>\n<li>检测是否是可迭代对象的方法：isinstance(list,Iterable)</li>\n</ul>\n<p>可迭代协议就是内部实现了<code>__iter__</code>方法。其中<code>__iter__</code>方法就是一个迭代器，包含迭代器的对象就是可迭代对象。</p>\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>自动抛出异常退出（<code>StopIteration</code>）</p></blockquote>\n<p><strong>作用</strong>：在进行遍历时，每每循环一次都会返回下一个数据，直到读完所有的数据为止。迭代器的作用就是记住访问到了第几条数据，以便于拿到下一条数据。<br><strong>本质</strong>：就是把存储数据和遍历数据分开来。<br><strong>优点</strong>：节省内存。不依赖索引取值。惰性计算。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>迭代器必须有<code>__iter__</code>和<code>__next__</code>方法。</p></blockquote>\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><p><strong>本质</strong>：是一个迭代器，即生成器是一种特殊的迭代器。<br><strong>特点</strong>：惰性运算，开发者自定义。<br><strong>生成器函数</strong>：在生成器函数中，用yield语句而不是return语句，yield语句一次返回一个结果。在其中两个结果的中间，函数是挂起的状态，以便于下次从离开的地方开始执行而不是从头开始。<br><strong>生成器表达式</strong>：类似于列表推导式，但生成器是按需取结果，而不是一次性来构建一个结果列表。</p>\n<h5 id=\"参考文章-1\"><a href=\"#参考文章-1\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><ul>\n<li><a href=\"https://blog.csdn.net/br1999/article/details/120895476\">迭代器和生成器详解_小白是美女的博客-CSDN博客_什么是迭代器和生成器</a></li>\n</ul>\n<h4 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h4><p><strong>字典的特性</strong>：</p>\n<p>字典(dict)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在dict中<code>key</code>是 唯一的. 在保存的时候, 根据key来计算出⼀个内存地址. 然后将<code>key-value</code>保存在这个地址中. 这种算法被称为hash算法, 所以, 切记, 在dict中存储的<code>key-value</code>中的<code>key</code>必须是可hash的</p>\n<ol>\n<li><p>用{}表示，<code>&#123;key:value&#125;</code>，每个键值对用冒号 :分割，每个键值对之间用逗号 ,分割，整个字典包括在花括号 {}之 中</p>\n</li>\n<li><p>由于dict是按<code>key</code>查找，所以，在一个dict中，<code>key</code>不能重复Key键的唯一性(什么是唯一性，比如key是li,那么就不能在有一个key是li)</p>\n</li>\n<li><p>存储的<code>key:value</code>是没有顺序的，没有索引(但3.6版本开始变的有序)</p>\n</li>\n<li><p>键可以用字符串、数字、布尔值、元组(不可变的数据类型)(可以hash)表示，但不可以用列表、集合(可以变的数据类型)表示，value没有要求.可以保存任意类型的数据</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>已知的可哈希(不可变)的数据类型: <code>int</code>, <code>str</code>, <code>tuple</code>, <code>bool</code></p>\n<p>不可哈希(可变)的数据类型: <code>list</code>, <code>dict</code>, <code>set</code>”</p></blockquote>\n<h5 id=\"参考文章-2\"><a href=\"#参考文章-2\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><ul>\n<li><a href=\"https://blog.csdn.net/weixin_27298377/article/details/112928689\">python 字典 键值 数据类型_python基础数据类型–字典_Florelle的博客-CSDN博客</a></li>\n</ul>\n<h4 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h4><p>Python 的GC模块主要运用了引用计数来跟踪和回收垃圾；通过“标记-清除”解决容器对象可能产生的循环引用问题；通过分代回收以空间换时间进一步提高垃圾回收的效率。</p>\n<p>也即采用“引用计数“为主(实时性，一旦没有引用，内存就直接释放了)，“标记-清除”与“分代收集”两种机制为辅的策略。</p>\n<ol>\n<li><p><strong>引用计数</strong></p>\n<p>为每一个对象维护一个引用计数器，当一个对象的引用被创建或者复制时，(对象的引用)计数器+1，当一个对象的引用被销毁时，计数器的值-1，当计数器的值为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</p>\n</li>\n<li><p><strong>标记-清除</strong></p>\n<p>“标记-清除”的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象，Python中的循环引用总是发生在容器container对象之间，也就是能够在内部持有其他对象的对象(比如：list、dict、class等)。这也使得该方法带来的开销只依赖于容器对象的数量。</p>\n<ul>\n<li><strong>原理（简约版）：</strong>在python的底层，再维护一个链表，链表中专门放那些可能存在循环引用的对象(list/tuple/dict/set)。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p><strong>原理（详细版）：</strong></p>\n<p>将集合中对象的引用计数复制一份副本，用于找寻root object集合(该set中的对象是不能被回收的)。当成功找到root object集合，首先将现在的内存链表一分为二，一条链表维护root object集合，成为root链表；另外一条维护剩下的对象，成为unreachable链表。</p>\n<p>一旦在标记的过程中，发现现在在unreachable链表且可能存在被root链表中直接或间接引用的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。</p>\n</li>\n<li><p><strong>缺点：</strong></p>\n<p>该机制所带来的额外操作和需要回收的内存块成正比。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>分代回收</strong>活的越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。</li>\n</ol>\n<h5 id=\"参考文章-3\"><a href=\"#参考文章-3\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><ul>\n<li><a href=\"https://www.jianshu.com/p/42eda41c4bd1\">python垃圾回收机制(超详细) - 简书 (jianshu.com)</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv4862303/\">5、Python语法入门之垃圾回收机制 - 哔哩哔哩 (bilibili.com)</a></li>\n</ul>\n","feature":true,"text":"魔术方法 __init__ 为构建好的对象赋予初始化 __new__ 分配内存空间，并返回构建好的对象（地址） __del__ 从内存中清除对象，对象会默认执行方法。具体执行的时间节点 __call__ 当作函数执行时会被默认自动调用 __str__ 打印一个对象的时候，默认调用...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">魔术方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">可迭代对象、迭代器、生成器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">可迭代对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">生成器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-1\"><span class=\"toc-text\">参考文章</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">字典</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-2\"><span class=\"toc-text\">参考文章</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-3\"><span class=\"toc-text\">参考文章</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Python：Python2与Python3","uid":"c4c29a0f3ee5d4305d5533c1af569c42","slug":"Python：Python2与Python3","date":"2022-12-10T13:20:33.000Z","updated":"2022-12-11T02:58:28.516Z","comments":true,"path":"api/articles/Python：Python2与Python3.json","keywords":null,"cover":"https://images.unsplash.com/photo-1670258897358-1e0347859dab","text":" print() vs print Unicode vs ASCII 除法：浮点 vs 整数 StandardError废弃，统一使用Exception；raise去除raise IOError, &quot;&quot;格式，统一为raise IOError(&quot;fil...","link":"","photos":[],"count_time":{"symbolsCount":383,"symbolsTime":"1 mins."},"categories":[{"name":"Python面试题","slug":"Python面试题","count":15,"path":"api/categories/Python面试题.json"}],"tags":[{"name":"Python","slug":"Python","count":10,"path":"api/tags/Python.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"feature":true}}