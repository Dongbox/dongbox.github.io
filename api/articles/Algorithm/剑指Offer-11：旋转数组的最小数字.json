{"title":"剑指Offer-11：旋转数组的最小数字","uid":"90b1ec3d38561ac8554926b985f123c0","slug":"Algorithm/剑指Offer-11：旋转数组的最小数字","date":"2022-12-20T02:33:53.000Z","updated":"2022-12-20T02:46:35.223Z","comments":true,"path":"api/articles/Algorithm/剑指Offer-11：旋转数组的最小数字.json","keywords":null,"cover":"https://images.unsplash.com/photo-1671479754018-9fbcb053d608","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p><a href=\"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=y8llrks\">剑指 Offer 11. 旋转数组的最小数字 - 力扣（Leetcode）</a></p>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>\n<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p>\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token comment\"># 示例</span>\n输入：numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n输出：<span class=\"token number\">1</span>\n\n输入：numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n输出：<span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"方法：二分法\"><a href=\"#方法：二分法\" class=\"headerlink\" title=\"方法：二分法\"></a>方法：二分法</h3><p>为什么本题二分法不用 <code>nums[m]</code> 和 <code>nums[i]</code> 作比较？</p>\n<p>二分目的是判断 m 在哪个排序数组中，从而缩小区间。而在 <code>nums[m]&gt;nums[i]</code> 情况下，无法判断 <code>m</code> 在哪个排序数组中。本质上是由于 <code>j</code> 初始值肯定在右排序数组中； <code>i</code> 初始值无法确定在哪个排序数组中。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">minArray</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">:</span>\n            m <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span>\n            <span class=\"token comment\"># m 一定在 左排序数组 中，即旋转点 x 一定在 [m+1,j] 闭区间内。</span>\n            <span class=\"token keyword\">if</span> numbers<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> numbers<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> i <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\t\t\t<span class=\"token comment\"># m 一定在 右排序数组 中，即旋转点 x 一定在[i,m] 闭区间内。</span>\n            <span class=\"token keyword\">elif</span> numbers<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> numbers<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> j <span class=\"token operator\">=</span> m\n            <span class=\"token comment\"># 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i,m] 还是 [m+1,j] 区间中。</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> j <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">return</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"正确性证明：\"><a href=\"#正确性证明：\" class=\"headerlink\" title=\"正确性证明：\"></a>正确性证明：</h4><p>当 <code>nums[m]=nums[j]</code> 时，无法判定 <code>m</code> 在左（右）排序数组，自然也无法通过二分法安全地缩小区间，因为其会导致旋转点 <code>x</code> 不在区间 <code>[i, j]</code> 内。</p>\n<p>而证明 <code>j=j−1</code> 正确（缩小区间安全性），需分为两种情况：</p>\n<p>当 <code>x&lt;j</code> 时： 易得执行 <code>j=j−1</code> 后，旋转点 <code>x</code> 仍在区间 <code>[i,j]</code> 内。</p>\n<p>当 <code>x=j</code> 时： 执行 <code>j=j−1</code> 后越过（丢失）了旋转点 <code>x</code> ，但最终返回的元素值 <code>nums[i]</code> 仍等于旋转点值 <code>nums[x]</code> 。</p>\n<p>由于 <code>x=j</code> ，因此 <code>nums[x]=nums[j]=nums[m]≤number[i]</code> ;<br>又由于 <code>i≤m&lt;j</code> 恒成立，因此有 m&lt;x ，即此时 m 一定在左排序数组中，因此 <code>nums[m]≥nums[i]</code>;</p>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度 *O(log⁡2N)*： 在特例情况下（例如 [1,1,1,1]），会退化到 <em>O(N)<em>。<br>空间复杂度 <em>O(1)</em> ：</em>i,j,m</em> 变量使用常数大小的额外空间。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/102826/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/\">剑指 Offer 11. 旋转数组的最小数字 - 力扣（Leetcode）</a></li>\n</ul>\n","feature":true,"text":"问题剑指 Offer 11. 旋转数组的最小数字 - 力扣（Leetcode） 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":9,"path":"api/tags/Algorithm.json"},{"name":"Leetcode","slug":"Leetcode","count":9,"path":"api/tags/Leetcode.json"},{"name":"查找算法","slug":"查找算法","count":5,"path":"api/tags/查找算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%B3%95\"><span class=\"toc-text\">方法：二分法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E%EF%BC%9A\"><span class=\"toc-text\">正确性证明：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"虚心学习，用心爱人~","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"剑指Offer-04：二维数组中的查找","uid":"e5e2148adfe0122b920f670391f658d9","slug":"Algorithm/剑指Offer-04：二维数组中的查找","date":"2022-12-20T01:01:53.000Z","updated":"2022-12-20T01:07:45.820Z","comments":true,"path":"api/articles/Algorithm/剑指Offer-04：二维数组中的查找.json","keywords":null,"cover":"https://images.unsplash.com/photo-1664877705363-984a353c0438","text":"问题剑指 Offer 04. 二维数组中的查找 - 力扣（Leetcode） 在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":9,"path":"api/tags/Algorithm.json"},{"name":"Leetcode","slug":"Leetcode","count":9,"path":"api/tags/Leetcode.json"},{"name":"查找算法","slug":"查找算法","count":5,"path":"api/tags/查找算法.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"虚心学习，用心爱人~","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"feature":true}}