{"title":"剑指Offer-30：包含min函数的栈","uid":"cec078924c15a69261a840497da55575","slug":"Algorithm/剑指Offer-30：包含min函数的栈","date":"2022-12-19T06:07:01.000Z","updated":"2022-12-19T08:59:55.573Z","comments":true,"path":"api/articles/Algorithm/剑指Offer-30：包含min函数的栈.json","keywords":null,"cover":"https://images.unsplash.com/photo-1667747501985-40fa56e5cebc","content":"<h3 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h3><p><a href=\"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=y8llrks\">剑指 Offer 30. 包含min函数的栈 - 力扣（Leetcode）</a></p>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token comment\"># 示例</span>\nMinStack minStack <span class=\"token operator\">=</span> new MinStack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nminStack<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nminStack<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nminStack<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nminStack<span class=\"token punctuation\">.</span><span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> 返回 <span class=\"token operator\">-</span><span class=\"token number\">3.</span>\nminStack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nminStack<span class=\"token punctuation\">.</span>top<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> 返回 <span class=\"token number\">0.</span>\nminStack<span class=\"token punctuation\">.</span><span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> 返回 <span class=\"token operator\">-</span><span class=\"token number\">2.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"方法：辅助线\"><a href=\"#方法：辅助线\" class=\"headerlink\" title=\"方法：辅助线\"></a>方法：辅助线</h3><h4 id=\"理解栈结构先进后出的性质\"><a href=\"#理解栈结构先进后出的性质\" class=\"headerlink\" title=\"理解栈结构先进后出的性质\"></a>理解栈结构先进后出的性质</h4><ul>\n<li><p>对于栈来说，如果一个元素 <code>a</code> 在入栈时，栈里有其它的元素 <code>b, c, d</code>，那么无论这个栈在之后经历了什么操作，只要 <code>a</code> 在栈中，<code>b, c, d</code>就一定在栈中，因为在 <code>a</code> 被弹出之前，<code>b, c, d</code> 不会被弹出。</p>\n</li>\n<li><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 <code>a</code>，那么我们就可以确定栈里面现在的元素一定是 <code>a, b, c, d</code>。</p>\n</li>\n<li><p>那么，我们可以在每个元素 <code>a</code> 入栈时把当前栈的最小值 <code>m</code> 存储起来。在这之后无论何时，如果栈顶元素是 <code>a</code>，我们就可以直接返回存储的最小值 <code>m</code>。</p>\n</li>\n</ul>\n<p>我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MinStack</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        self<span class=\"token punctuation\">.</span>min_stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>math<span class=\"token punctuation\">.</span>inf<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</span>\n        self<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>min_stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>min_stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># min函数立大功</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</span>\n        self<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>min_stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">top</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>min_stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><ul>\n<li><p>时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)O(1)O(1)。因为栈的插入、删除与读取操作都是 O(1)O(1)O(1)，我们定义的每个操作最多调用栈操作两次。</p>\n</li>\n<li><p>空间复杂度：O(n)O(n)O(n)，其中 nnn 为总操作数。最坏情况下，我们会连续插入 nnn 个元素，此时两个栈占用的空间为 O(n)O(n)O(n)。</p>\n</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solutions/1398785/bao-han-minhan-shu-de-zhan-by-leetcode-s-i2fk/\">剑指 Offer 30. 包含min函数的栈 - 力扣（Leetcode）</a></li>\n</ul>\n","text":"问题：剑指 Offer 30. 包含min函数的栈 - 力扣（Leetcode） 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 # 示例 MinStack minStack =...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":4,"path":"api/tags/Algorithm.json"},{"name":"Leetcode","slug":"Leetcode","count":4,"path":"api/tags/Leetcode.json"},{"name":"栈","slug":"栈","count":2,"path":"api/tags/栈.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">问题：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%EF%BC%9A%E8%BE%85%E5%8A%A9%E7%BA%BF\"><span class=\"toc-text\">方法：辅助线</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E6%A0%88%E7%BB%93%E6%9E%84%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%E7%9A%84%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">理解栈结构先进后出的性质</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"剑指Offer-06：从尾到头打印链表","uid":"c8c4451151af101d353c3e3bce84b1fa","slug":"Algorithm/剑指Offer-06：从尾到头打印链表","date":"2022-12-19T08:03:03.000Z","updated":"2022-12-19T08:24:41.532Z","comments":true,"path":"api/articles/Algorithm/剑指Offer-06：从尾到头打印链表.json","keywords":null,"cover":null,"text":"问题剑指 Offer 06. 从尾到头打印链表 - 力扣（Leetcode） 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 # 示例 输入：head = [1,3,2] 输出：[2,3,1] 方法：辅助栈法算法流程： 入栈： 遍历链表，将各节点值 push...","link":"","photos":[],"count_time":{"symbolsCount":843,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"链表","slug":"链表","count":2,"path":"api/tags/链表.json"},{"name":"Algorithm","slug":"Algorithm","count":4,"path":"api/tags/Algorithm.json"},{"name":"Leetcode","slug":"Leetcode","count":4,"path":"api/tags/Leetcode.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Python：进程和线程","uid":"02a08c5f44cac23b9de92edc205edce8","slug":"Python/Python：进程和线程","date":"2022-12-17T02:26:37.000Z","updated":"2022-12-17T03:03:52.816Z","comments":true,"path":"api/articles/Python/Python：进程和线程.json","keywords":null,"cover":"https://images.unsplash.com/photo-1671154453575-b0cea38bb19a","text":" 进程——资源分配的最小单位，线程——程序执行的最小单位 简介 进程（Process） 进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。 线程（thread） 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 进程有独立...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Python","slug":"Python","count":12,"path":"api/categories/Python.json"}],"tags":[{"name":"Python面试题","slug":"Python面试题","count":18,"path":"api/tags/Python面试题.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}}}}