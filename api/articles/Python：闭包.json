{"title":"Python：闭包","uid":"1e75bb07e5af1c2f8f74b87cd88f4fd3","slug":"Python：闭包","date":"2022-12-10T07:50:14.000Z","updated":"2022-12-10T08:18:25.669Z","comments":true,"path":"api/articles/Python：闭包.json","keywords":null,"cover":"https://images.unsplash.com/photo-1657212850528-c738d087e6f8","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。</p>\n<p>上面这段话实际上解释了闭包的一个定义和两个作用：</p>\n<ul>\n<li><p>定义：闭包就是能够读取外部函数内的变量的函数。（前面已经讲解过）</p>\n</li>\n<li><p>作用1：闭包是将外层函数内的局部变量和外层函数的外部连接起来的一座桥梁。</p>\n</li>\n<li><p>作用2：将外层函数的变量持久地保存在内存中。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>支持将函数当成对象使用的编程语言，一般都支持闭包。比如Python, JavaScript。</p></blockquote>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><h4 id=\"1-读取函数内部的变量\"><a href=\"#1-读取函数内部的变量\" class=\"headerlink\" title=\"1. 读取函数内部的变量\"></a>1. <strong>读取函数内部的变量</strong></h4><p>有时候会为了保证命名空间的干净而把一些变量隐藏到函数内部，作为局部变量。但是由于Python中作用域的搜索顺序，函数内的变量不会被函数外的代码读取到。</p>\n<p>如果这时候想要函数外部的代码能够读取函数内部的变量，那么就可以使用闭包。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>闭包存在的意义就是它夹带了外部变量（私货），如果它不夹带私货，它和普通的函数就没有任何区别。<strong>同一个的函数</strong>夹带了<strong>不同的私货</strong>，就实现了不同的功能。  其实你也可以这么理解，闭包和面向接口编程的概念很像，可以把闭包理解成轻量级的接口封装。—-<a href=\"https://www.zhihu.com/people/5bb8700e1883c346752afff210c72723\">@Wayne</a></p></blockquote>\n<h4 id=\"2-让函数内部的局部变量始终保持在内存中\"><a href=\"#2-让函数内部的局部变量始终保持在内存中\" class=\"headerlink\" title=\"2. 让函数内部的局部变量始终保持在内存中\"></a><strong>2. 让函数内部的局部变量始终保持在内存中</strong></h4><p>一般来说，函数内部的局部变量在这个函数运行完以后，就会被Python的垃圾回收机制从内存中清除掉。如果我们希望这个局部变量能够长久的保存在内存中，那么就可以用闭包来实现这个功能。</p>\n<p>闭包使得<strong>函数</strong>的实例对象的内部变量，变得很像一个<strong>类</strong>的实例对象的属性，可以一直保存在内存中，并不断的对其进行运算。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，闭包既可以长久的保存变量又不会造成全局污染。</li>\n<li>闭包使得函数内局部变量的值始终保持在内存中，不会在外层函数调用后被自动清除。</li>\n<li>当外层函数返回了内层函数后，外层函数的局部变量还被内层函数引用</li>\n<li>带参数的装饰器，那么一般都会生成闭包。</li>\n<li>闭包在爬虫以及web应用中都有很广泛的应用。</li>\n</ul>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/453787908\">Python闭包（Closure）详解 - 知乎 (zhihu.com)</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/22229197\">深入浅出python闭包 - 知乎 (zhihu.com)</a></p>\n</li>\n</ul>\n","feature":true,"text":"简介在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 上面这段话实际上解释了闭包的一个定义和两个作用： ...","link":"","photos":[],"count_time":{"symbolsCount":967,"symbolsTime":"1 mins."},"categories":[{"name":"Python面试题","slug":"Python面试题","count":14,"path":"api/categories/Python面试题.json"}],"tags":[{"name":"Python","slug":"Python","count":8,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1. 读取函数内部的变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%AE%A9%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD\"><span class=\"toc-text\">2. 让函数内部的局部变量始终保持在内存中</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol>","author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Python：Django模型类","uid":"8410d9c49c9d1e56959240bb5a60df1e","slug":"Python：Django模型类","date":"2022-12-10T08:17:36.000Z","updated":"2022-12-10T09:40:44.609Z","comments":true,"path":"api/articles/Python：Django模型类.json","keywords":null,"cover":"https://images.unsplash.com/photo-1658953229664-e8d5ebd039ba","text":"模型类继承一共有三种继承模式： 抽象基类 多表继承 代理模型 1. 抽象基类该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。 from django.db import models class CommonInfo(models.Model):...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Python面试题","slug":"Python面试题","count":14,"path":"api/categories/Python面试题.json"}],"tags":[{"name":"Python","slug":"Python","count":8,"path":"api/tags/Python.json"},{"name":"Django","slug":"Django","count":2,"path":"api/tags/Django.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"MYSQL优化与多表查询","uid":"44618c7f6520782d55b1b922f6fa7af4","slug":"MYSQL优化与多表查询","date":"2022-12-10T05:52:12.000Z","updated":"2022-12-10T12:50:53.522Z","comments":true,"path":"api/articles/MYSQL优化与多表查询.json","keywords":null,"cover":"https://images.unsplash.com/photo-1665512983234-5053c892365b","text":"参考文章 最全Mysql查询性能优化总结（超详细） - 知乎 (zhihu.com) 【MySQL笔记】多表查询（JOIN ON）_java小白。。的博客-CSDN博客_mysql join on ","link":"","photos":[],"count_time":{"symbolsCount":102,"symbolsTime":"1 mins."},"categories":[{"name":"Python面试题","slug":"Python面试题","count":14,"path":"api/categories/Python面试题.json"}],"tags":[{"name":"Database","slug":"Database","count":1,"path":"api/tags/Database.json"}],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}}}}