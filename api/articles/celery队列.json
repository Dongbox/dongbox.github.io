{"title":"celery队列","uid":"867e4beaadd4d5a00bee5d31d8c3bbbf","slug":"celery队列","date":"2022-12-10T02:35:04.000Z","updated":"2022-12-10T02:38:16.501Z","comments":true,"path":"api/articles/celery队列.json","keywords":null,"cover":"https://images.unsplash.com/photo-1666543257223-095dcc9a12fd","content":"<h2 id=\"Celery简介\"><a href=\"#Celery简介\" class=\"headerlink\" title=\"Celery简介\"></a>Celery简介</h2><h4 id=\"1-什么是任务队列\"><a href=\"#1-什么是任务队列\" class=\"headerlink\" title=\"1. 什么是任务队列\"></a>1. 什么是任务队列</h4><p>任务队列是一种用于在线程或计算机之间分配工作的机制。</p>\n<p>任务队列的输入是一个称为任务的工作单元，有专门的职程（<strong>Worker</strong>）进行不断的监视任务队列，进行执行新的任务工作。</p>\n<p>Celery 通过消息机制进行通信，通常使用中间件（<strong>Broker</strong>）作为客户端和职程（<strong>Worker</strong>）调节。启动一个任务，客户端向消息队列发送一条消息，然后中间件（<strong>Broker</strong>）将消息传递给一个职程（<strong>Worker</strong>），最后由职程（<strong>Worker</strong>）执行。</p>\n<p>Celery 可以有多个职程（Worker）和中间件（Broker），用来提高Celery的高可用性以及横向扩展能力。</p>\n<p>Celery 需要消息中间件来进行发送和接收消息。 RabbitMQ 和 Redis 中间件的功能比较齐全，但也支持其它的实验性的解决方案，其 中包括 SQLite 进行本地开发。</p>\n<p>Celery 可以在一台机器上运行，也可以在多台机器上运行，甚至可以跨数据中心运行。</p>\n<h4 id=\"2-Celery组件\"><a href=\"#2-Celery组件\" class=\"headerlink\" title=\"2. Celery组件\"></a>2. Celery组件</h4><p><strong>Celery 扮演生产者和消费者的角色</strong></p>\n<ul>\n<li><p>Celery Beat：任务调度器。Beat 进程会读取配置文件的内容，周期性的将配置中到期需要执行的任务发送给任务队列。</p>\n</li>\n<li><p>Celery Worker：执行任务的消费者，通常会在多台服务器运行多个消费者，提高运行效率。</p>\n</li>\n<li><p>Broker：消息代理，队列本身。 也称为消息中间件。 接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方(通常是消息队列或者数据库)。</p>\n</li>\n<li><p>Producer：任务生产者。 调用 Celery API ，函数或者装饰器，而产生任务并交给任务队列处理的都是任务生产者。</p>\n</li>\n<li><p>Result Backend : 任务处理完成之后保存状态信息和结果，以供查询。</p>\n</li>\n</ul>\n<p><strong>celery架构图</strong></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-5beea41170db3f01ea379bc1e6520bda_720w.webp\"></p>\n<h4 id=\"3-Celery特点\"><a href=\"#3-Celery特点\" class=\"headerlink\" title=\"3. Celery特点\"></a>3. Celery特点</h4><ul>\n<li><strong>高可用</strong></li>\n</ul>\n<p>当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务。</p>\n<ul>\n<li><strong>快速</strong></li>\n</ul>\n<p>一个单进程的 Celery 每分钟可以处理数以百万的任务，而且延迟仅为亚毫秒（使用 RabbitMQ、 librabbitmq 在优化过后）。</p>\n<ul>\n<li><strong>灵活</strong></li>\n</ul>\n<p>Celery 的每个部分几乎都可以自定义扩展和单独使用，例如自定义连接池、序列化方式、压缩方式、日志记录方式、任务调度、生产者、消费者、中间件（Broker）等。</p>\n<h3 id=\"4-Celery功能\"><a href=\"#4-Celery功能\" class=\"headerlink\" title=\"4. Celery功能\"></a>4. Celery功能</h3><ul>\n<li><strong>监控</strong></li>\n</ul>\n<p>可以针对整个流程进行监控，内置的工具可以实时说明当前集群的概况。</p>\n<ul>\n<li><strong>调度</strong></li>\n</ul>\n<p>可以通过调度功能在一段时间内指定任务的执行时间 datetime，也可以根据简单每隔一段时间进行执行重复的任务，支持分钟、小时、星期几，也支持某一天或某一年的Crontab表达式。</p>\n<ul>\n<li><strong>工作流</strong></li>\n</ul>\n<p>可以通过“canvas”进行组成工作流，其中包含分组、链接、分块等等。</p>\n<p>简单和复杂的工作流程可以使用一组“canvas“组成，其中包含分组、链接、分块等。</p>\n<ul>\n<li><strong>资源（内存）泄漏保护</strong></li>\n</ul>\n<p>–max-tasks-per-child 参数适用于可能会出现资源泄漏（例如：内存泄漏）的任务。</p>\n<ul>\n<li><strong>时间和速率的限制</strong></li>\n</ul>\n<p>您可以控制每秒/分钟/小时执行任务的次数，或者任务执行的最长时间，也将这些设置为默认值，针对特定的任务或程序进行定制化配置。</p>\n<ul>\n<li><strong>自定义组件</strong></li>\n</ul>\n<p>开发者可以定制化每一个职程（Worker）以及额外的组件。职程（Worker）是用 “bootsteps” 构建的-一个依赖关系图，可以对职程（Worker）的内部进行细粒度控制。</p>\n<h4 id=\"5-版本要求\"><a href=\"#5-版本要求\" class=\"headerlink\" title=\"5. 版本要求\"></a>5. 版本要求</h4><p>Celery 4.0 运行：</p>\n<ul>\n<li><p>Python ❨2.7,3.4,3.5❩  </p>\n</li>\n<li><p>PyPy ❨5.4,5.5❩  </p>\n</li>\n</ul>\n<p>这是支持 Python2.7 的最后一个版本，从下一个版本Celery5.x开始，需要Python3.5或更高的版本。</p>\n<p>如果您的 Python 运行环境比较老，则需要使用旧版本的Celery：</p>\n<ul>\n<li>Python 2.6：Celery 3.1 或更早版本。</li>\n<li>Python 2.5：Celery 3.0 或更早版本。</li>\n<li>Python 2.4：Celery 2.2 或更早版本。</li>\n</ul>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/337138573?utm_id=0\">Celery 分布式任务队列 - 知乎 (zhihu.com)</a></li>\n</ul>\n","feature":true,"text":"Celery简介1. 什么是任务队列任务队列是一种用于在线程或计算机之间分配工作的机制。 任务队列的输入是一个称为任务的工作单元，有专门的职程（Worker）进行不断的监视任务队列，进行执行新的任务工作。 Celery 通过消息机制进行通信，通常使用中间件（Broker）作为客户...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Python面试题","slug":"Python面试题","count":1,"path":"api/tags/Python面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Celery%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">Celery简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97\"><span class=\"toc-text\">1. 什么是任务队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Celery%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">2. Celery组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Celery%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3. Celery特点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Celery%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">4. Celery功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%89%88%E6%9C%AC%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">5. 版本要求</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol></li></ol>","author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"redis用过哪些数据结构？怎么保存的?","uid":"06c05b6d3f59577fc268e145e3219741","slug":"redis用过哪些数据结构？怎么保存的","date":"2022-12-09T12:15:37.000Z","updated":"2022-12-10T02:34:41.056Z","comments":true,"path":"api/articles/redis用过哪些数据结构？怎么保存的.json","keywords":null,"cover":"https://images.unsplash.com/photo-1666126444655-23492b1532e2","text":"Redis 的五种基本数据类型String（字符串）简介:String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M 简单使用举例: set key value、get key等 应用场景：共享session、分布式锁，计数...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Dongbo Xie","slug":"blog-author","avatar":"https://images-1257166372.cos.ap-shanghai.myqcloud.com/hexo/avator.png","link":"/","description":"准备开始，记录自己所有的操作吧!","socials":{"github":"https://github.com/Dongbox","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5412853900","zhihu":"","csdn":"https://blog.csdn.net/dongbox_","juejin":"","customs":{}}},"feature":true}}