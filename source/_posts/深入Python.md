---
title: 深入Python
date: 2022-12-13 15:33:51
tags: Python面试题
categories: Python
cover: https://images.unsplash.com/photo-1669192532750-5165016ad000
---

### 魔术方法

- `__init__` 为构建好的对象赋予初始化

- `__new__` 分配内存空间，并返回构建好的对象（地址）

- `__del__` 从内存中清除对象，对象会默认执行方法。具体执行的时间节点

- `__call__`  当作函数执行时会被默认自动调用

- `__str__` 打印一个对象的时候，默认调用；在使用str()对对象强制类型转换后，输出结果时会调用

- `__repr__` repr方法作用和str方法的作用一样，都是输出对象打印的字符串格式。但最大的不同点在于：  
  在可变容器中，对象打印默认会调用repr方法。

##### 参考文章

- [python——魔术方法_影中人lx的博客-CSDN博客_python魔术方法](https://blog.csdn.net/qq_53893431/article/details/123979718)

#### 

#### 可迭代对象、迭代器、生成器

#### 可迭代对象

- 可迭代对象就是从循环中依次取出来的对象。
- 常见的可迭代对象有：list，tuple，string，dict，range
- 常见的不可迭代的对象有：数字，布尔值
- 检测是否是可迭代对象的方法：isinstance(list,Iterable)

可迭代协议就是内部实现了`__iter__`方法。其中`__iter__`方法就是一个迭代器，包含迭代器的对象就是可迭代对象。

#### 迭代器

> 自动抛出异常退出（`StopIteration`）

**作用**：在进行遍历时，每每循环一次都会返回下一个数据，直到读完所有的数据为止。迭代器的作用就是记住访问到了第几条数据，以便于拿到下一条数据。
**本质**：就是把存储数据和遍历数据分开来。
**优点**：节省内存。不依赖索引取值。惰性计算。

> 迭代器必须有`__iter__`和`__next__`方法。

#### 生成器

**本质**：是一个迭代器，即生成器是一种特殊的迭代器。
**特点**：惰性运算，开发者自定义。
**生成器函数**：在生成器函数中，用yield语句而不是return语句，yield语句一次返回一个结果。在其中两个结果的中间，函数是挂起的状态，以便于下次从离开的地方开始执行而不是从头开始。
**生成器表达式**：类似于列表推导式，但生成器是按需取结果，而不是一次性来构建一个结果列表。

##### 参考文章

- [迭代器和生成器详解_小白是美女的博客-CSDN博客_什么是迭代器和生成器](https://blog.csdn.net/br1999/article/details/120895476)

#### 字典

**字典的特性**：

字典(dict)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在dict中`key`是 唯一的. 在保存的时候, 根据key来计算出⼀个内存地址. 然后将`key-value`保存在这个地址中. 这种算法被称为hash算法, 所以, 切记, 在dict中存储的`key-value`中的`key`必须是可hash的

1. 用{}表示，`{key:value}`，每个键值对用冒号 :分割，每个键值对之间用逗号 ,分割，整个字典包括在花括号 {}之 中

2. 由于dict是按`key`查找，所以，在一个dict中，`key`不能重复Key键的唯一性(什么是唯一性，比如key是li,那么就不能在有一个key是li)

3. 存储的`key:value`是没有顺序的，没有索引(但3.6版本开始变的有序)

4. 键可以用字符串、数字、布尔值、元组(不可变的数据类型)(可以hash)表示，但不可以用列表、集合(可以变的数据类型)表示，value没有要求.可以保存任意类型的数据

> 已知的可哈希(不可变)的数据类型: `int`, `str`, `tuple`, `bool`
> 
> 不可哈希(可变)的数据类型: `list`, `dict`, `set`”

##### 参考文章

- [python 字典 键值 数据类型_python基础数据类型--字典_Florelle的博客-CSDN博客](https://blog.csdn.net/weixin_27298377/article/details/112928689)

#### 回收机制

Python 的GC模块主要运用了引用计数来跟踪和回收垃圾；通过“标记-清除”解决容器对象可能产生的循环引用问题；通过分代回收以空间换时间进一步提高垃圾回收的效率。

也即采用“引用计数“为主(实时性，一旦没有引用，内存就直接释放了)，“标记-清除”与“分代收集”两种机制为辅的策略。

1. **引用计数**
   
   为每一个对象维护一个引用计数器，当一个对象的引用被创建或者复制时，(对象的引用)计数器+1，当一个对象的引用被销毁时，计数器的值-1，当计数器的值为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。

2. **标记-清除**
   
   “标记-清除”的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象，Python中的循环引用总是发生在容器container对象之间，也就是能够在内部持有其他对象的对象(比如：list、dict、class等)。这也使得该方法带来的开销只依赖于容器对象的数量。
   
   - **原理（简约版）：**
     
     在python的底层，再维护一个链表，链表中专门放那些可能存在循环引用的对象(list/tuple/dict/set)。
- **原理（详细版）：**
  
  将集合中对象的引用计数复制一份副本，用于找寻root object集合(该set中的对象是不能被回收的)。当成功找到root object集合，首先将现在的内存链表一分为二，一条链表维护root object集合，成为root链表；另外一条维护剩下的对象，成为unreachable链表。
  
  一旦在标记的过程中，发现现在在unreachable链表且可能存在被root链表中直接或间接引用的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。

- **缺点：**
  
  该机制所带来的额外操作和需要回收的内存块成正比。
3. **分代回收**
   
   活的越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。

##### 参考文章

- [python垃圾回收机制(超详细) - 简书 (jianshu.com)](https://www.jianshu.com/p/42eda41c4bd1)
- [5、Python语法入门之垃圾回收机制 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv4862303/)
